---
title: "wavClusteR Package Vignette"
author: "Federico Comoglio and Cem Sievers"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{wavClusteR}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

## Abstract

Different recently developed next-generation sequencing based methods (e.g. PAR-CLIP or Bisulphite sequencing) specifically induce nucleotide substitutions within the short reads with respect to the reference genome. This package provides functions for the analysis of the data obtained by such methods - with a major focus on PAR-CLIP - and exploits the experimentally induced substitutions in order to identify high confidence signals, such as RNA-binding sites, in the data. The workflow consists of two steps; (i) the estimation of a non-parametri two-component mixture model, identifying substitution frequencies most affected by the experimental procedure; (ii) a binding sites (clusters) identification algorithm which resolves clusters at high resolution. Key functions support multicore computing, if available. For a detailed description of the method see (Sievers et al., 2012; Comoglio et al., 2015).


## Preparing the input

Starting with a fastq file, a commonly used short read format, the short reads should be aligned to the reference genome using a short read aligner, e.g. Bowtie/Bowtie2 (Langmead et al., 2009). The output file (e.g. in SAM format) should then be converted to BAM format (e.g. using [samtools view](http://samtools.sourceforge.net/samtools.shtml) and sorted (e.g. using samtools sort). Since wavClusteR requires an indexed BAM file containing the short read alignments, a BAM index file should be generated from the sorted BAM file (see, e.g. samtools index).
The following code provides an example of the steps described above using the samtools toolkit. The first line is pseudo code. Please replace it with the aligner specific syntax.

```{r eval=FALSE}
	ALIGN: sample.fastq -> sample.sam
	CONVERT: samtools view -b -S sample.sam  -o sample.bam
	SORT: samtools sort sample.bam sample_sorted
	INDEXING: samtools index sample_sorted.bam
```

###Example dataset

In this vignette, we consider as an example a chunk of a published Argonaute 2 (AGO2) PAR-CLIP data set obtained from human HEK293 cells (Kishore et al., 2011). This chunk contains reads mapping to chromosome X in the interval: 23996166 - 24023263. This data set is locally provided by wavClusteR.

###Importing short reads into the R session

An indexed BAM file can be loaded into the R session using the readSortedBam function. This calls scanBam from Rsamtools and extracts the mismatch MD field and the read sequence from the BAM file, returning a GRanges object.

```{r eval=TRUE}
library(wavClusteR)
filename <- system.file( "extdata", "example.bam", package = "wavClusteR" )
Bam <- readSortedBam(filename = filename)
Bam
```

###Extracting the informative positions used for model parameter estimation} 

To estimate the mixture model both mixing coefficients and density functions (components) have to be estimated from the data. To this purpose, genome-wide substitutions are first identified and filtered according to a minimum coverage value at substitutions. The minimum coverage, which should be chosen to account for variables such as sequencing depth, provides a way to select the positions used for parameter estimation. Hence, it can be used to tune the stringency of the analysis. There is no obvious theoretical justification to find the optimal minimum coverage. However since relative substitution frequencies have to be computed for parameter estimation, the minimum coverage will influence the variance of the estimate. The lowest minimum coverage used for our analysis was 10.
The getAllSub function identifies the genomic positions that show at least one substitution and satisfy the minimum coverage requirement. It returns a GRanges object specifying the genomic position, the strand, the observed substitution (e.g. "TC" implies a T in the reference genome and a C in the read), the strand-specific coverage and the number of observed substitutions at the specific position.

```{r eval=TRUE}
countTable <- getAllSub( Bam, minCov = 10 )
head( countTable )
```

Once all substitutions are computed, the corresponding substitution profile can be plotted with plotSubstitutions. This function returns a barplot showing the total number of genomic positions that exhibit a given type of substitution and highlights the substitution type that is expected to be generated by the experimental procedure. In addition, the percentage of substitution of this type with respect to all identified substitutions is indicated. This plot conveys information about the quality of the data and can be used to compare different data sets generated by the same experimental conditions.
%

```{r fig.width=5, fig.height=5, fig.align='center', eval=TRUE}
plotSubstitutions( countTable, highlight = "TC" )
```

##Estimating the non-parametric mixture model

The genomic positions identified above (see getAllSub) are used to estimate the mixture model densities and mixing coefficients. The estimation is performed by the function fitMixtureModel for the substitution of interest. The function returns a list containing:

+ the two mixing coefficients (l1 and l2)
+ the two individual components (p1 and p2)
+ the full density (p)

Given an observed relative substitution frequency, the model is used to compute the posterior probability that it was obtained by experimental induction.
Given the GRanges object countTable the model can be estimated as follows:

```{r eval=FALSE}
model <- fitMixtureModel(countTable, substitution = "TC")
```

The small size of the example dataset would not allow a reliable model estimation. Therefore, the mixture model for the entire AGO2 dataset has been precomputed and is provided by wavClusteR for convenience. The model can be loaded by

```{r eval=TRUE}
data(model)
str(model)
```

Once the mixture model is estimated, the model fit can be inspected and the RSF interval most likely to be affected by the experimental procedure can be identified using the getExpInterval function. Besides then high-confidence RSF interval, two plots are returned. The first one illustrates the estimated densities p, p_1 and p_2 and ensuing log odds o

	o=\rm{log}\frac{p(k=2|x)}{p(k=1|x)}
 
whereas the second plot shows the resulting posterior class probability, i.e. the probability that a given relative substitution frequency (RSF, horizontal axis) has been experimentally induced. The area under the curve corresponding to the returned RSF interval is colored, and the RSF interval indicated. By default, getExpInterval returns the RSF interval according to the Bayes classifier, i.e. RSF values having probability larger than or equal to 0.5.

```{r fig.width=5, fig.height=5, fig.align='center', eval=TRUE}
(support <- getExpInterval( model, bayes = TRUE ) )
```

However, the user can modify the stringency of the analysis and determine a custom RSF interval in two ways:

1. By setting the rightProb and leftProb parameters to a desired posterior probability cutoff, e.g.

```{r fig.width=5, fig.height=5, fig.align='center', eval=TRUE}
(support <- getExpInterval( model, bayes = FALSE, leftProb = 0.9, rightProb = 0.9 ) )
```

2. By inspecting the posterior class probability density and directly enter the RSF interval boundaries when calling high-confidence substitutions (see call to getHighConfSub function in the next section) 

Finally, the model can be used to produce further diagnostic plots. Particularly, besides the barplot returned by plotSubstitutions (see previous section), the total number of reads carrying a given substitution and an RSF-based partitioning of genomic positions with substitutions is returned by

```{r fig.width=5, fig.height=5, fig.align='center', eval=TRUE}
plotSubstitutions( countTable, highlight = "TC", model )
```

##Identifying protein binding sites (clusters) 

###Filtering high confidence signal sites

High-confidence transitions are identified by the getHighConfSub function. The RSF interval returned by getExpInterval can either directly enter a getHighConfSub function call as

```{r eval=TRUE}
highConfSub <- getHighConfSub( countTable, 
                               support = support, 
                               substitution = "TC" )
```

or, alternatively, the interval can be specified by the user as

```{r eval=FALSE}
highConfSub <- getHighConfSub( countTable, 
                               supportStart = 0.2, 
                               supportEnd = 0.7, 
                               substitution = "TC" )
```

The function returns a GRanges object with genomic position, strand, strand-specific coverage, occurence (count), and relative substitution frequency (rsf) for each identified high-confidence substitution.

```{r eval=TRUE}
head( highConfSub )
```

###Identifying cluster boundaries and computing cluster statistics

Binding sites (referred to as clusters) can be identified by the function getClusters. This function takes as input high-confidence substitution sites and the overall coverage across the genome, which can be computed using GenomicRanges as

```{r eval=TRUE}
coverage <- coverage( Bam )
coverage$chrX
```

For versions >=2.0, cluster boundaries  are resolved by default using the Mini-Rank Norm (MRN) algorithm (Comoglio et al., 2015). Briefly, this algorithm finds an optimal cluster boundary for each high-confidence substitution by solving an optimization problem that integrates prior knowledge on the geometry of PAR-CLIP clusters. The algorithm first considers differences in the coverage function. Then, it removes background fluctuations via learning of a local background threshold or hard thresholding (default). This choice is controlled by the threshold parameter. The MRN algorithm proceeds by evaluating all ensuing possible cluster boundaries and computes ranking of boundary signals and cluster widths, which are finally used to find the optimum cluster boundary for each high-confidence substitution. Adoption of the MRN algorithm is strongly recommended as computationally faster (up to 10x) and more sensitive than the previously adopted cluster identification algorithm based on continuous wavelet transform (CWT) of the coverage function (see Sievers et al., 2012). The latter computes the continuous wavelet transform (CWT) of the coverage function on a 1 kb window centered at a high-confidence substitution site. The minimum required signal-to-noise ratio can be specified with the parameter snr (default snr=3). Since multiple high-confidence substitution sites can localize in close proximity, the step size (controlled by the step parameter) can be set to values larger than 1 (default), such that the CWT is computed only if the subsequent high-confidence substitution is located further than the specified value from the previously considered position. Starting from the peak positions the cluster boundaries are then expanded. This algorithm is still maintained for reproducibility and can be called by setting method = "cwt" in the getClusters function.

Clusters can be computed as

```{r eval=TRUE}
clusters <- getClusters( highConfSub = highConfSub,
                         coverage = coverage,
                         sortedBam = Bam,
                         method = "mrn",
                         threshold = 1,
                         cores = 1 )
clusters
```

Two options are available:

1. Hard thresholding, based on a globally applied threshold determining the extent of noise in the coverage function. Empirically, 10% of the required minCov at high-confidence substitutions worked well in practice on all tested datasets (e.g. a value of 1 in this example where minCov = 10. Alternatively, 10% of the mode of the coverage distribution at high-confidence substitutions can represent a valuable choice.
2. Local thresholding, based on a global estimation of background levels via a Gaussian mixture model. Omitting the threshold parameter in the call to getClusters enables local thresholding

```{r eval=TRUE}
clusters <- getClusters( highConfSub = highConfSub,
                         coverage = coverage,
                         sortedBam = Bam,
                         method = "mrn",
                         cores = 1 )
clusters
```

Once the clusters are identified, the reported genomic regions can be merged in a strand-specific manner and statistics for each resulting cluster, which we call a wavCluster, can be computed using the filterClusters function, which takes as input the following elements:

+ The identified clusters
+ The high-confidence substitution sites
+ The genome-wide coverage
+ The mixture model
+ A BSgenome object containing the correct reference sequence
+ The reference base expected to be converted by the experimental procedure
+ The minimum required width of a wavCluster
\
The function can be called as follows:

```{r eval=TRUE}
require(BSgenome.Hsapiens.UCSC.hg19)

wavclusters <- filterClusters( clusters = clusters, 
                   highConfSub = highConfSub,
                   coverage = coverage, 
                   model = model, 
                   genome = Hsapiens, 
                   refBase = "T", 
                   minWidth = 12)

wavclusters
```

The call returns a GRanges object where for each wavCluster:

+ the number of high-confidence transitions (Ntransitions)
+ the the mean coverage (MeanCov)
+ the number of bases in the reference genome of the same type as the specified refBase (NbasesInRef)
+ the estimated cross-linking efficiency (CrossLinkEff), i.e. the ratio between Ntransitions and NbasesInRef
+ the genomic sequence (Sequence)
+ the sum of the log odds (SumLogOdds), contributed by each high-confidence transition within the cluster
+ the relative log odds (RelLogOdds), i.e. the ratio between SumLogOdds and Ntransitions

is returned. The relative log odds can be used to rank clusters according to statistical confidence.

##Output post-processing


wavClusteR provides a number of functions (summarized in the table below) for post-processing of the identified wavClusters.

Task  | Function | Output format |
------------- | ------------- | ------------- |
Export all identified substitutions or high-confidence substitutions | exportHighConfSub | BED 
Export clusters | exportClusters | BED 
Export coverage function | exportCoverage | BigWig
Visualize the size distribution of wavClusters | plotSizeDistribution | histogram
Annotate clusters with respect to genomic features (e.g. CDS, introns, 3'-UTRs, 5'-UTRs) in a strand-specific manner | annotateClusters | dot chart, vector
Compute metagene profiles of wavClusters, where the density of wavClusters is represented as a function of a reference genomic coordinates | getMetaGene | line plot, vector
Compute metaTSS profiles based on all aligned reads in the input BAM file | \Rfunction{getMetaTSS} | line plot, vector
Visualize wavClusteR statistics and meta data to learn pairwise relationships between variables | plotStatistics | pairs plot

###Exporting substitutions, wavClusters and coverage function 

High-confidence substitutions can be exported with

```{r eval=FALSE}
exportHighConfSub( highConfSub = highConfSub, 
                   filename = "hcTC.bed", 
                   trackname = "hcTC", 
                   description = "hcTC" )
```

where trackname and description correspond to the very same attributes in the UCSC BED file format specification and define the name of the BED track and its description, respectively. Notice that by replacing highConfSub with another set of substitutions (e.g. all identified substitutions of a given type), those can be exported and visualized using the same function call.

Similarly, wavClusters can be exported as

```{r eval=FALSE}
exportClusters( clusters = wavclusters, 
                filename = "wavClusters.bed", 
                trackname = "wavClusters", 
                description = "wavClusters" )
```

and the coverage function can be exported as

```{r eval=FALSE}
exportCoverage( coverage = coverage, filename = "coverage.bigWig" )
```

###Annotating binding sites

wavClusters can be annotated with respect to known genomic features using the annotateClusters function, which generates a strand-specific dot chart representing wavClusters annotation. The function takes as an input the wavClusters and a transcriptDB object containing all transcript annotations. The latter can either be generated a priori using the makeTxDbFromUCSC (from the GenomicFeatures package) or is automatically fetched and built by annotateClusters if not provided. If multiple calls to annotateClusters are planned, the recommended solution is to build the object once as

```{r eval=FALSE}
txDB <- makeTxDbFromUCSC(genome = "hg19", tablename = "ensGene")
```

Then, the annotateClusters can be called as follows

```{r eval=FALSE}
annotateClusters( clusters = wavclusters, 
              txDB = txDB, 
              plot = TRUE, 
              verbose = TRUE)
```

Four dot charts are returned by the function. The first plot (top) represents the percentage of clusters mapping to different transcript features localized on the same strand as the identified clusters. Please note that the dot chart above was produced by providing wavClusters identified on the entire AGO2 dataset. Multiple hits, i.e. wavClusters that overlap with more than one genomic feature, are reported as "multiple", whereas wavClusters that map outside of the considered features are labeled as "other". The latter are then annotated with respect to features on the antisense strand and the results are represented in the second plot. The third  plot represents the relative sequence length of different compartments relative to the total transcriptome length of the organism being considered (clearly, this plot does not depend on the PAR-CLIP data). These ratios are then used to normalize the counts on the sense strand in order to produce the fourth (bottom) plot, which can be used to show enrichments or depletion of clusters in the different functional compartments.

###Computing cluster metagene profiles

A graphical representation of the density of wavClusters as a function of a binning of genomic coordinates across all annotated genes can be obtained using the getMetaGene function as follows:

```{r eval=FALSE}
getMetaGene( clusters = wavclusters, 
             txDB = txDB, 
             upstream = 1e3, 
             downstream = 1e3, 
             nBins = 40, 
             nBinsUD = 10, 
             minLength = 1, 
             plot = TRUE,
             verbose = TRUE ) 
```

In the function call above, genes were divided in 40 bins (nBins) and an upstream/downstream region spanning 1kb was considered (width controlled by upstream and downstream parameters). This, in turn, was subdivided in 10 bins (nBinsUD). No restriction on gene length was applied (minLength). The numeric vector of length nBins + 2*nBinsUD with normalized counts is returned by the function and therefore can be used, for example, to compare the distribution of wavClusters across several PAR-CLIP samples.
In addition to metagene profiles, metaTSS profiles based on all aligned reads in the input BAM file can be generated using the getMetaTSS function. A default function call is as follows:

```{r eval=FALSE}
getMetaTSS( sortedBam = Bam, 
            txDB = txDB, 
            upstream = 1e3, 
            downstream = 1e3, 
            nBins = 40, 
            unique = FALSE, 
            plot = TRUE, 
            verbose = TRUE ) 
```

where the upstream and downstream parameters control the width of the window centered on the transcription start site (TSS) to be considered, nBins determines the resolution of the profile. If unique is enabled, then overlapping TSSs are discarded. The numeric vector of length nBins with normalized read counts is returned by the function and therefore can be used, for example, to compare several PAR-CLIP samples.

###Visualizing the size distribution of wavClusters

The size distribution of wavClusters is visualized as a histogram and returned by the following function call

```{r fig.width=5, fig.height=5, fig.align='center', eval=TRUE}
plotSizeDistribution( clusters = wavclusters, col = "skyblue2" )
```

where additional parameters of the hist function can be passed in the function call. Finally, if showCov=TRUE, a scatter plot of average cluster coverage vs. cluster length is returned

```{r fig.width=5, fig.height=5, fig.align='center', eval=TRUE}
plotSizeDistribution( clusters = wavclusters, showCov = TRUE, col = "skyblue2" )
```

###Visualizing wavClusteR statistics and meta data

The size distribution of wavClusters is visualized as a histogram and returned by the following function call

```{r fig.width=5, fig.height=5, fig.align='center', eval=FALSE}
plotStatistics( clusters = wavclusters, 
                corMethod = "spearman", 
                lower = panel.smooth )
```

## Session Info
```{r eval=TRUE}
sessionInfo()
```

## References

Sievers, C., Schlumpf, T., Sawarkar, R., Comoglio, F. & Paro, R. (2012) Mixture models and wavelet transforms reveal high confidence RNA-protein interaction sites in MOV10 PAR-CLIP data. Nucleic Acids Res 40(2), e160

Comoglio, F., Sievers, C. & Paro, R. (2015) Sensitive and highly resolved inidentification of RNA-protein interaction sites in PAR-CLIP data. BMC Bioinformatics, 16, 32

Langmead,B., Trapnell,C., Pop,M. \& Salzberg,S.L. (2009)
Ultrafast and memory-efficient alignment of short DNA sequences to the human genome. Genome Biol 10, R25

Kishore, S. et al. (2011)
A quantitative analysis of CLIP methods for identifying binding sites of RNA-binding proteins. Nature Methods 8(7), 559-564

Morgan, M. & Pages, H. Rsamtools: Binary alignment (BAM), variant call (BCF), or tabix
file import, [http://bioconductor.org/packages/release/bioc/html/Rsamtools.
html](http://bioconductor.org/packages/release/bioc/html/Rsamtools.
html)

Pages, H., BSgenome: Infrastructure for Biostrings-based genome data packages

Kent WJ, Sugnet CW, Furey TS, Roskin KM, Pringle TH, Zahler AM, Haussler D. (2002) The human genome browser at UCSC. Genome Res. 12(6), 996-1006.


